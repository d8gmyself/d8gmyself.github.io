<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Guava限流器-RateLimiter]]></title>
    <url>%2F2018%2F05%2F26%2FGuava%E9%99%90%E6%B5%81%E5%99%A8-RateLimiter%2F</url>
    <content type="text"><![CDATA[最简单的限流思想最近在学习Guava使用的时候看到了RateLimiter，也就是限流器，其类的注释里面有提到最简单的限流思想如下： The simplest way to maintain a rate of QPS is to keep the timestamp of the last granted request, and ensure that (1/QPS) seconds have elapsed since then. For example, for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn’t granted earlier than 200ms after the last one, then we achieve the intended rate. If a request comes and the last request was granted only 100ms ago, then we wait for another 100ms. At this rate, serving 15 fresh permits(i.e. for an acquire(15) request) naturally takes 3 seconds. 简单来说，就是我们可以通过记录最近一次被授权请求的请求时间，来达到限流的目的。比如说QPS为5（每秒允许通过5个请求），那么我们可以认为是两个请求之间需要间隔1/QPS秒，也就是200毫秒，通过判断当前请求时间和最近一次授权时间的时间间隔是否大于等于200毫秒来决定当前请求是否允许执行。当然，如果小于200ms我们也可以选择更新最新授权时间+等待，或者直接抛弃两种处理方式。 下面我们来看一下Guava里面到底是怎么实现的。 Guava中RateLimiter层次结构 常见用法12345678910111213141516171819202122232425262728293031323334353637public class RateLimiterTest &#123; public static void main(String[] args) throws Exception &#123; smoothBursty(); smoothWarmingUp(); &#125; public static void smoothBursty() throws Exception &#123; System.out.println(&quot;-----------------SmoothBursty-----------------&quot;); RateLimiter rateLimter = RateLimiter.create(10); Stopwatch started = Stopwatch.createStarted(); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire(10, 100, 10Mills):&quot; + rateLimter.tryAcquire(10, 100, TimeUnit.MILLISECONDS)); TimeUnit.SECONDS.sleep(5); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire(40):&quot; + rateLimter.tryAcquire(40)); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire(3000Mills):&quot; + rateLimter.tryAcquire(3000, TimeUnit.MILLISECONDS)); System.out.println(started.elapsed(TimeUnit.MILLISECONDS) + &quot;:tryAcquire(3100Mills):&quot; + rateLimter.tryAcquire(3100, TimeUnit.MILLISECONDS)); System.out.println(&quot;-----------------SmoothBursty-----------------&quot;); &#125; public static void smoothWarmingUp() throws Exception &#123; System.out.println(&quot;-----------------SmoothWarmingUp-----------------&quot;); RateLimiter rateLimter = RateLimiter.create(10, 5, TimeUnit.SECONDS); Stopwatch started = Stopwatch.createStarted(); System.out.println(started.elapsed(TimeUnit.SECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.SECONDS) + &quot;:tryAcquire(10, 100Mills):&quot; + rateLimter.tryAcquire(10, 100, TimeUnit.MILLISECONDS)); System.out.println(started.elapsed(TimeUnit.SECONDS) + &quot;:tryAcquire(5000Mills):&quot; + rateLimter.tryAcquire(1000, TimeUnit.MILLISECONDS)); TimeUnit.SECONDS.sleep(5); System.out.println(started.elapsed(TimeUnit.SECONDS) + &quot;:tryAcquire():&quot; + rateLimter.tryAcquire()); System.out.println(started.elapsed(TimeUnit.SECONDS) + &quot;:tryAcquire(40):&quot; + rateLimter.tryAcquire(40)); System.out.println(&quot;-----------------SmoothWarmingUp-----------------&quot;); &#125;&#125; SmoothBurstySmoothBursty翻译成中文，是平稳和突发，意思就是这个限流器可以平稳限流，也可以应对突发的大量请求。 SmoothBursty的一些关键点 令牌法 采用令牌算法来进行限流 囤积令牌 默认最多囤积一秒的令牌数 下一次可通行时间点 记录下一次开始发放令牌的时间点 前人挖坑，后人埋 如果当前请求时间大于记录的下一次可用时间点，不管请求多少令牌，直接放过，根据请求的令牌数以及当前囤积的令牌数来将“下一次可用时间点”往后推；如果当前求情时间小于记录的下一次可用时间点，则wait一段时间（这段时间=下一次可用时间点 - 当前请求时间），然后将下一次可用时间点往后推，推后的时长 = 当前请求令牌数 * 生成一个令牌需要的时间 SmoothBursty中的一些名词解释 maxBurstSeconds 可以理解为RateLimiter未被使用时，可以囤积多少秒的令牌 storedPermits 当前囤积的令牌数 maxPermits 最大可囤积令牌数 stableIntervalMicros 每生成一个令牌的时间间隔，比如QPS为5，那么每200ms生成一个令牌 nextFreeTicketMicros 可以理解为下次产生可用令牌的时间，这个时间每次acquire的时候都会更新，只能是一个将来的时间点 stopwatch 可以理解为一个计时器，在RateLimiter被创建的时候开始计时 mutexDoNotUseDirectly 锁对象 简单工作原理图如上图所示，横向的矩形框表示时间，假设QPS为1，每一格为1秒,上面的箭头表示下次允许请求通过的时间点（nextFreeTicketMicros），下面的箭头表示每次请求，针对每次请求做分析（只针对acquire，不包含tryAcquire）： A1，请求1个令牌，此时限流器刚启动，nextFreeTicketMicros为N0，接收到A1请求后，允许请求通过，当前没有令牌可用，所以透支一个，nextFreeTicketMicros会被推到N1（因为生成一个令牌需要1秒） A2，请求1个令牌，由于nextFreeTicketMicros为N1，所以该请求需要wait一段时间，这段时间等于图中A2到N1的黄色部分，然后生成A2所需要的令牌又需要1秒钟，所以nextFreeTicketMicros会被推到N2 A3，请求5个令牌，由于N2到N7没有请求产生，所以到了A3请求时，会有一个令牌囤积（QPS为1，SmoothBursty默认囤积1秒产生的令牌），然后nextFreeTicketMicros首先会被推到N7，由于A3请求5个令牌，用掉囤积的一个后，还需要透支4个，所以nextFreeTicketMicros又会被推到N11，A3请求通过 A4，请求1个令牌，由于nextFreeTicketMicros为N11，所以A4请求需要wait一段时间，这段时间等于图中A4到N11的黄色部分，生成A4所需要的令牌需要1秒，所以nextFreeTicketMicros会被推到N12 下面的代码可以用来验证上面的流程： 1234567891011121314151617public class RateLimiterTest &#123; public static void main(String[] args) throws Exception &#123; RateLimiter rateLimter = RateLimiter.create(1); Stopwatch started = Stopwatch.createStarted(); rateLimter.acquire(); System.out.println(&quot;A1:&quot; + started.elapsed(TimeUnit.SECONDS)); TimeUnit.MILLISECONDS.sleep(300); rateLimter.acquire(); System.out.println(&quot;A2:&quot; + started.elapsed(TimeUnit.SECONDS)); TimeUnit.SECONDS.sleep(6); rateLimter.acquire(5); System.out.println(&quot;A3:&quot; + started.elapsed(TimeUnit.SECONDS)); TimeUnit.MILLISECONDS.sleep(1500); rateLimter.acquire(); System.out.println(&quot;A4:&quot; + started.elapsed(TimeUnit.SECONDS)); &#125;&#125; 打印结果为： A1:0A2:1A3:7A4:11 分别代表A1请求在第0秒通过，A2在第1秒通过，A3在第7秒通过，A4在第11秒通过 至于tryAcquire，就是判断当前请求时间是否 &gt;= nextFreeTicketMicros - timeout，如果成立，走类似acquire的逻辑，返回true；如果当前请求时间加上timeout时长还达不到nextFreeTicketMicros，直接返回false 关键方法源码关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public double acquire(int permits) &#123; //获得所需令牌要wait多久 long microsToWait = reserve(permits); //sleep stopwatch.sleepMicrosUninterruptibly(microsToWait); return 1.0 * microsToWait / SECONDS.toMicros(1L);&#125;final long reserve(int permits) &#123; //校验permits必须大于0 checkPermits(permits); synchronized (mutex()) &#123; return reserveAndGetWaitLength(permits, stopwatch.readMicros()); &#125;&#125;final long reserveAndGetWaitLength(int permits, long nowMicros) &#123; //获得令牌可用时刻 long momentAvailable = reserveEarliestAvailable(permits, nowMicros); //通过令牌可用时刻 - 当前请求时刻来决定当前请求是否需要sleep return max(momentAvailable - nowMicros, 0);&#125;/** * 核心方法 */final long reserveEarliestAvailable(int requiredPermits, long nowMicros) &#123; resync(nowMicros); long returnValue = nextFreeTicketMicros; //本次请求消耗多少囤积的令牌 double storedPermitsToSpend = min(requiredPermits, this.storedPermits); //本次请求需要新生成多少令牌 double freshPermits = requiredPermits - storedPermitsToSpend; //对于SmoothBursty来说，计算生成freshPermits个令牌需要多久 long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (long) (freshPermits * stableIntervalMicros); //将nextFreeTicketMicros向后推，推后的时间等于生成freshPermits个令牌所需要的时间 this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros); //扣减消耗的囤积令牌 this.storedPermits -= storedPermitsToSpend; //返回的是当前请求来临时的nextFreeTicketMicros return returnValue;&#125;void resync(long nowMicros) &#123; /* * 如果当前请求时间大于nextFreeTicketMicros，计算囤积令牌并将nextFreeTicketMicros设置为当前请求时间 * nextFreeTicketMicros只能是现在或者将来，如果是一个过去的时间，会被同步为现在 */ if (nowMicros &gt; nextFreeTicketMicros) &#123; double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros(); storedPermits = min(maxPermits, storedPermits + newPermits); nextFreeTicketMicros = nowMicros; &#125;&#125;public boolean tryAcquire(int permits, long timeout, TimeUnit unit) &#123; long timeoutMicros = max(unit.toMicros(timeout), 0); checkPermits(permits); long microsToWait; synchronized (mutex()) &#123; long nowMicros = stopwatch.readMicros(); if (!canAcquire(nowMicros, timeoutMicros)) &#123; return false; &#125; else &#123; microsToWait = reserveAndGetWaitLength(permits, nowMicros); &#125; &#125; stopwatch.sleepMicrosUninterruptibly(microsToWait); return true;&#125;private boolean canAcquire(long nowMicros, long timeoutMicros) &#123; //queryEarliestAvailable(nowMicros) = nextFreeTicketMicros return queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros;&#125; SmoothWarmingUp与SmoothBursty的主要区别新增名词工作原理关键方法源码SmoothWarmingUp的大部分代码其实是和SmoothBursty共用的，这里主要列出一些有区别的地方 扩展阅读常见的限流算法 计数法 滑动窗口 漏斗法 令牌法]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Guava</tag>
        <tag>限流器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PropertyDescriptor使用时遇到的坑]]></title>
    <url>%2F2018%2F05%2F25%2FPropertyDescriptor%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[有一段时间特别喜欢链式编程，然后把自己的IDEA中自动生成getters and setters的setters模板设置成了Builder模式，生成的代码如下： 12345678910111213public class Person &#123; privat String name; public String getName() &#123; return this.name; &#125; public Person setName(String name) &#123; this.name = name; return this; &#125; &#125; 相信有不少人也喜欢这么写，这样写起来比单独再写一个Builder要简单很多，但是在最近遇到一个问题，就是在使用PropertyDescriptor的时候，会遇到java.beans.IntrospectionException: Method not found: setName的问题，依稀这段代码在很久以前使用的时候还是没有问题的，为了查明问题，翻阅了PropertyDescriptor的源码，发现在JDK1.7以及1.7之后，PropertyDescriptor类的getWriteMethod方法发成了改变，具体如下： 红框部分代码，是在1.7以及1.7以后新加入的，对set方法的返回值做了约束，返回值必须为void。 JDK为什么要这么改？个人猜想有两点，一是JavaBean规范，再一个可能是因为Java中的方法特征签名和字节码层面的方法特征签名不一致的问题，在Java语言中，方法的特征签名包括方法名、参数顺序以及参数类型，在字节码层面，方法签名特征还多了返回值以及受检查异常列表。所以，为了更好的兼容性，还是老老实实写完整的Builder模式吧。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
